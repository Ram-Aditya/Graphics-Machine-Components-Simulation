#include<GL/gl.h>
#include <stdio.h>
#include <math.h>
#include <GL/glut.h>
#include<iterator>
#include<map>
#include<iostream>
#include<vector>
#define maxHt 1080
#define maxWd 1920
#define maxVer 10000

using namespace std;
struct Tuple
{
    int xEndPoints[2],yEndPoints[2];
    int yMax;
    int xOfyMin;
    float inverseSlope;
};

class SortedEdgeTable
{
    map<int,vector<Tuple>> buckets;
    int bucketsCount;
    void traverseEdgeTable();
    void sortEdgeTable();
    void deleteTuples(int bucketNo, int yMax);
    void incrementX(int bucketNo);
    void addTuple(int x1, int y1, int x2, int y2);
    void sortBucket(vector<Tuple> & bar);
    void mergeSortBucket(vector<Tuple>&left, vector<Tuple>& right, vector<Tuple>& bars);
};


void SortedEdgeTable::addTuple(int x1, int y1, int x2, int y2)
{
    float slope,inverseSlope;
	int yMax, yMin, xOfyMin, scanlineNo;
    if (y2==y1)
            return;
	if (x1==x2)
		inverseSlope=0.0;
	else
        inverseSlope = ((float)(x2-x1))/((float)(y2-y1));
    scanlineNo=yMin=min(y1,y2);
    yMax=max(y1,y2);
	if (yMin==y1)
		xOfyMin=x1;
	else
		xOfyMin=x2;
    Tuple t;
    t.yMax=yMax;
    t.xOfyMin=xOfyMin;
    t.inverseSlope=inverseSlope;
    t.xEndPoints[0]=x1;t.xEndPoints[1]=x2;
    t.yEndPoints[0]=y1;t.yEndPoints[1]=y2;
    if(buckets.count(scanlineNo)==0)
    {
        vector<Tuple> vecT;
        vecT.push_back(t);
        buckets.insert(pair<int,vector<Tuple>>(scanlineNo,vecT));
    }
    else
        buckets.at(scanlineNo).push_back(t);
}

void SortedEdgeTable::incrementX(int bucketNo)
{
    vector<Tuple> * bucketVec = &buckets.at(bucketNo);
    for(vector<Tuple>::iterator it=(*bucketVec).begin(); it!=(*bucketVec).end(); ++it )
        (*it).xOfyMin += (*it).inverseSlope;
}

void SortedEdgeTable::deleteTuples(int bucketNo, int yMax)
{
    vector<Tuple> * bucketVec = &buckets.at(bucketNo);
    for(vector<Tuple>::iterator it=(*bucketVec).begin(); it!=(*bucketVec).end(); ++it )
        if((*it).yMax == yMax )
            (*bucketVec).erase(it);
}

void SortedEdgeTable::traverseEdgeTable()
{
    for( map<int,vector<Tuple>>::const_iterator mapIt = buckets.begin(); mapIt != buckets.end(); ++mapIt )
    {
        int key = (*mapIt).first;
        vector<Tuple> vect = (*mapIt).second;
        printf("Scanline(yMin) %d : \n",key);
        for(vector<Tuple>::iterator it=vect.begin(); it!=vect.end(); ++it )
            printf("(%d,%d) to (%d,%d) (%d,%d,%f) \n",(*it).xEndPoints[0],(*it).yEndPoints[0],(*it).xEndPoints[1],(*it).yEndPoints[1],(*it).yMax,(*it).xOfyMin,(*it).inverseSlope);
        printf("\n");
    }
}

void SortedEdgeTable::sortBucket(vector<Tuple> & bar)
{
    if (bar.size() <= 1) return;
    int mid = bar.size() / 2;
    vector<Tuple> left;
    vector<Tuple> right;
    for (size_t j = 0; j < mid;j++)
        left.push_back(bar[j]);
    for (size_t j = 0; j < (bar.size()) - mid; j++)
        right.push_back(bar[mid + j]);
    sortBucket(left);
    sortBucket(right);
    mergeSortBucket(left, right, bar);
}

void structCopy(Tuple *t1, Tuple *t2)
{
    //Copy t2 to t1
    (*t1).yMax=(*t2).yMax;
    (*t1).xOfyMin=(*t2).xOfyMin;
    (*t1).xEndPoints[0]=(*t2).xEndPoints[0];
    (*t1).xEndPoints[1]=(*t2).xEndPoints[1];
    (*t1).yEndPoints[0]=(*t2).yEndPoints[0];
    (*t1).yEndPoints[1]=(*t2).yEndPoints[1];
    (*t1).inverseSlope=(*t2).inverseSlope;
}

void SortedEdgeTable::mergeSortBucket(vector<Tuple>&left, vector<Tuple>& right, vector<Tuple>& bars)
{
    int nL = left.size();
    int nR = right.size();
    int i = 0, j = 0, k = 0;

    while (j < nL && k < nR)
    {
        if (left[j].xOfyMin < right[k].xOfyMin) {
            structCopy(&bars[i],&left[j]);
            j++;
        }
        else {
            structCopy(&bars[i],&right[k]);
            k++;
        }
        i++;
    }
    while (j < nL) {
        structCopy(&bars[i],&left[j]);
        j++; i++;
    }
    while (k < nR) {
        structCopy(&bars[i],&right[k]);
        k++; i++;
    }
}

void SortedEdgeTable::sortEdgeTable()
{
    for( map<int,vector<Tuple>>::const_iterator mapIt = buckets.begin(); mapIt != buckets.end(); ++mapIt )
    {
        int key = (*mapIt).first;
        sortBucket(buckets.at(key));
    }
}
